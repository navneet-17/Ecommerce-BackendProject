****class-1:1Sep ********
****class-2:4Sep ********
-Product Controller talks to a service.
-Service has the business logic.

Rule of Thumb:
- If a Controller needs to talk to a service, we need to create an interface for the service.
    This is because we can have multiple implementations of the service.

-We create a service package and create a product service interface.
-We create a product service implementation class - FakeProductService.
- Every method in the controller will have a corresponding method with the same name preferably in the service.
- In REST every resource is identified by a URI and we should get that using path variable and not request param.
    Request param is used for query parameters or configuration parameters.
// Dependency Injection
- We need to inject the service into the controller.
- We can do this by using the @Autowired annotation.
    We can achieve this by three ways
    1. using the constructor injection.
    2. using the setter injection.
    3. using the field injection.
- We will use the constructor injection. This is the preferred way as it is immutable. Constructor injection is generally preferred for its many advantages in terms of code quality, maintainability, and testability.
- We can use the @Qualifier annotation to specify which implementation of the service we want to use if we have multiple implementations of the service.
 Example: if we have 2 classes - FakestoreProductService and SelfProductServiceImpl and they both implement the ProductService interface.
    We can use the @Qualifier annotation to specify which implementation we want to use.
     E.g:     // constructor injection
             @Autowired
              public ProductController(@Qualifier("fakeStoreProductService") ProductService productService) {
                  this.productService = productService;
              }

               and annotate it accordingly in the implementation class.
              @Service("fakeStoreProductService")
              public class FakeStoreProductService implements ProductService {
              }
- We can also use the @Primary annotation to specify which implementation we want to use if we have multiple implementations of the service.

* Whenever we write @autowire, the relevant object is picked from the spring container and injected into the class.

***********************************
We call the fakestore API to get the products.
API at https://fakestoreapi.com/products is returning a list of products in the form of JSON.
We need to convert this JSON into a list of products as Java objects, as we cannot use JSON directly in our application.
We can use the Jackson library to convert JSON to Java objects.
Whenever we are sending or receiving data from an external system, we need to convert it into Java objects.
These objects may not be exactly the same as the objects we use in our application.
So, as a rule of thumb, we should not use our model objects. This is because the models are replicating the database tables.
We should create separate objects for the external system as the objects in the external systems may change.
for handling the external system, we should create DTOs (Data Transfer Objects).
DTOs are the objects that we use to transfer data between the external system and our application. These objects are not persisted in the database.
We can use the same objects for both sending and receiving data.
Calling the external system is the responsibility of the service.
Calling the API:
- whenever we call a third party API, we need to use the language specific library to call the API.
Like we use axios for calling the API in React(JS), Retrofit in Android(Kotlin), python request etc.
- In Java, we can use the Spring RestTemplate to call the API from an external system.
We use the builder pattern to create the RestTemplate; since this will have
a lot of fields- URI, headers, body, method, connection auth tokem etc.

First we create the Rest Template Builder:

@Service("fakestoreProductService")
public class FakestoreProductService implements ProductService{
    private final RestTemplateBuilder restTemplateBuilder;
    private String requestUrl = "https://fakestoreapi.com/products/1";
    public FakestoreProductService(RestTemplateBuilder restTemplateBuilder) {
        this.restTemplateBuilder = restTemplateBuilder;
    }
Then we create the Rest Template:
public String getProductById(Long id) {
        RestTemplate restTemplate = restTemplateBuilder.build();

This RestTemplate is a class that is provided by Spring which has a lot of methods to call the external system.
- Next, we need to get the response from the API, for a GET request.
    - For a GET request, we use the getForEntity method to get the response from the API
    - For a POST request, we use the postForEntity method to get the response from the API
    - For a PUT request, we use the put method to get the response from the API
    - For a DELETE request, we use the delete method to get the response from the API
    - For a PATCH request, we use the patchForObject method to get the response from the API

Coming back to our GET request, we use the getForEntity method to get the response from the API.
- The first parameter is the URI of the API.
- The second parameter is the type of the response we want to get from the API.
    - We can use the getForObject method if we want to get a single object from the API.
    - We can use the getForEntity method if we want to get multiple objects from the API.

Next, we create the URI:
private String requestUrl = "https://fakestoreapi.com/products";
restTemplate.getForEntity(requestUrl , Product[].class);

then we get the response and convert the response using the getForEntity method:
restTemplate.getForEntity(requestUrl , Product[].class);

- The getForEntity method returns a ResponseEntity object, so we store this accordingly.
ResponseEntity<Product[]> response = restTemplate.getForEntity(requestUrl, Product[].class);
In our case the Product[] class will be replaced by the FakeStoreProductDto.class In our case the Product[] class will be replaced by the FakeStoreProductDto.class.

- Now, this getForEntity method will return a ResponseEntity object with the body of <FakeStoreProductDto>
     ResponseEntity<FakeStoreProductDto> response = restTemplate.getForEntity(requestUrl , FakeStoreProductDto.class,id);
** We are using this response entity as it will also get us a lot of other things like the get status code etc.

** Issue with returning the FakeStoreProductDto.class in the controller directly is that this is highly dependent on the external system's API object.
We would want to return an object that is as per our system; independent of the external system's API object.

So, we will create a separate object for our system and then convert the FakeStoreProductDto.class to our object. We will use the ProductDTO object as Product is our system's object.

- We will create a DTO - GenericProductDto.java. This will have the details returned in the FakeStoreProductDto.class and the details that we want to return to the user.

This is how the new implementation will look like:
 public GenericProductDto getProductById(Long id) {
        RestTemplate restTemplate = restTemplateBuilder.build();
        ResponseEntity<FakeStoreProductDto> response =
                restTemplate.getForEntity(getProductRequestUrl, FakeStoreProductDto.class, id);

        FakeStoreProductDto fakeStoreProductDto = response.getBody();

        GenericProductDto product = new GenericProductDto();
        product.setImage(fakeStoreProductDto.getImage());
        product.setDescription(fakeStoreProductDto.getDescription());
        product.setTitle(fakeStoreProductDto.getTitle());
        product.setPrice(fakeStoreProductDto.getPrice());
        product.setCategory(fakeStoreProductDto.getCategory());
        return product;
    }

 * So, we have successfully called the external system and converted the response to our system's object and returned it to the user.
 This conversion is internally done by the Jackson library which is used by the RestTemplate to do so.

And with this we have successfully called the external system and made a GET request .
***************************************************
Post Request:
- We will create a new method in the service to create a product.
We will post a request that has our GenericProductDto in the request body and we use the @RequestBody annotation to do so.
- We will use the postForEntity method to post the request to the API.
- The first parameter is the URI of the API
- The second parameter is the request body
- The third parameter is the type of the response we want to get from the API.

    public GenericProductDto createProduct(GenericProductDto product) {
        RestTemplate restTemplate = restTemplateBuilder.build();
        ResponseEntity<GenericProductDto> response = restTemplate.postForEntity(
                createProductRequestUrl, product, GenericProductDto.class
        );
        return response.getBody();
    }

    * We will create a new method in the controller to create a product.
    * We will use the @PostMapping annotation to do so.
    * We will use the @RequestBody annotation to get the request body.

***API to get all products *********************************************************************
Similar to the get product by id, we will create a new method in the service to get all products.
We will use the getForEntity method to get the response from the API.
-> The first parameter is the URI of the API.
-> The second parameter is the type of the response we want to get from the API.
-> We will create a new method in the controller to get all products.
-> We will use the @GetMapping annotation to do so.
-> We will use the @ResponseBody annotation to return the response as the response body.

** For the get all products, List<FakeStoreProductDto> will throw an error due to the type erasure concept in Java.
- So, we will use the array of FakeStoreProductDto[] instead of List<FakeStoreProductDto> to get the response from the API.
- Then we will convert the FakeStoreProductDto[] to List<FakeStoreProductDto> and then to List<GenericProductDto> and then return it to the user.
****API to delete all products *********************************************************************
** HTTP Status Codes are returned by a Controller.
The fake store API returns the deleted product in the response body.
The fakestore API returns a 200 status code for a successful request while we will have to throw an exception if the product to be deleted is not present.
-- We will create a new method in the controller to delete all products.
-- We will create a new method in the service to delete all products.
-- We will use the @DeleteMapping annotation to do so.
-- We will use the @ResponseStatus annotation to specify the status code.
-- We will use the @ResponseBody annotation to return the response as the response body.

-- We will use the delete method to delete the product from the API.
-- The first parameter is the URI of the API.
-- The second parameter is the type of the response we want to get from the API.

** The fake store API returns the deleted product in the response body, but the default implementation of the delete method in the RestTemplate does not return anything. So we need to create a custom implementation of the delete method to get the response from the API.
--> We should ideally create a new class called CustomRestTemplate and extend the RestTemplate class. We will override the delete method and return the response from the API. But we will not do this as this is not the best practice. We will use the exchange method to get the response from the API.
** Implementing the delete method using the exchange method:
 We just copy the code template for creating a new product and make code changes in the required places to have it work for delete.
**** /////////////////// Existing code for creating a new product: /////////////////////////////////////////
    public <T> ResponseEntity<T> postForEntity(String url, @Nullable Object request, Class<T> responseType, Object... uriVariables) throws RestClientException {
        RequestCallback requestCallback = this.httpEntityCallback(request, responseType);
        ResponseExtractor<ResponseEntity<T>> responseExtractor = this.responseEntityExtractor(responseType);
        return (ResponseEntity)nonNull((ResponseEntity)this.execute(url, HttpMethod.POST, requestCallback, responseExtractor, uriVariables));
    }
/////////////////// Updating this as per our requirement for deleting an existing product: /////////////////////////////////////////
public GenericProductDto deleteProductById(Long id){
        RestTemplate restTemplate = restTemplateBuilder.build();
        RequestCallback requestCallback = restTemplate.acceptHeaderRequestCallback(FakeStoreProductDto.class);
        ResponseExtractor<ResponseEntity<FakeStoreProductDto>> responseExtractor = restTemplate.responseEntityExtractor(FakeStoreProductDto.class);
        ResponseEntity<FakeStoreProductDto> response = restTemplate.execute(specificProductRequestUrl, HttpMethod.DELETE, requestCallback, responseExtractor, id);
        FakeStoreProductDto fakeStoreProductDto = response.getBody();
        return convertFakeStoreProductIntoGenericProduct(fakeStoreProductDto);
    }
*** We have also created a method to convert the FakeStoreProductDto into GenericProductDto. *******************************************
    public GenericProductDto convertFakeStoreProductIntoGenericProduct(FakeStoreProductDto fakeStoreProductDto){
        GenericProductDto product = new GenericProductDto();
        product.setId(fakeStoreProductDto.getId());
        product.setImage(fakeStoreProductDto.getImage());
        product.setDescription(fakeStoreProductDto.getDescription());
        product.setTitle(fakeStoreProductDto.getTitle());
        product.setPrice(fakeStoreProductDto.getPrice());
        product.setCategory(fakeStoreProductDto.getCategory());
        return product;
    }
****** TODO: API to Update a product ***********************************************
**** create Exception Handling for the API calls.***
We will create a custom exception handler class in the exceptions package.
We will use the @ControllerAdvice annotation to do so.
We will use the @ExceptionHandler annotation to specify the exception we want to handle.










