$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$ class-9:11Sep Intro To Spring Data JPA, ORM, Hibernate,JDBC, Entities, UUIDs $$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

Adding the database connection to the project
1. Add the Spring Data JPA dependency to the pom.xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

2. Add the MySql dependency to the pom.xml
        <dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>

3. Add the database connection properties to the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
    spring.datasource.username=springuser
    spring.datasource.password=ThePassword
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

4. Add the database config in mysql workbench:
    create database scalerbackendproductservice;
    create user scalerbackendproductservice;
    grant all privileges on scalerbackendproductservice.* to scalerbackendproductservice;

5. Update the MYSQL host and user details in the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://localhost:3306/scalerbackendproductservice
    spring.datasource.username=scalerbackendproductservice
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

****** TODO: Mapped Superclass ******************************
1. Create a new class called BaseEntity
2. Add the @MappedSuperclass annotation to the BaseEntity class
3. Add the @Id and @GeneratedValue(strategy = GenerationType.IDENTITY) annotations to the id field

 ****UUID*****************************************
Let's look at the data type options for generating the primary key
*String:
  Having the Primary Keys as String is a terrible idea.
 -> Whenever we are storing a table in a particular database, for the primary key, an index is also created usually.
 --> The index is used to quickly search for a particular record in the table. (The index is stored in a data structure called a B-Tree.)
 --> However, the B-Tree data structure is not efficient when the data type is String. This indexing for String can be huge in itself and can significantly slow down the queries.
    --> The String data type is not efficient for the primary key and is almost always a terrible idea.

* Integer/Long:
    -> The Integer/Long data type is efficient for the primary key.

    *Benefits of the integer/long primary key:
        1. The primary key is auto generated by the database
        2. The primary key is unique across the table
        3. The primary key is sequential
        4. The Integer/Long data type is efficient for the primary key

    *Drawbacks of the integer/long primary key:
    --> However, the Integer/Long data type has a few drawbacks.
        --> When the systems are distributed, the Integer/Long data type is not efficient.
        --> When the systems are distributed, the Integer/Long data type is not unique neither sequential across the table.
        --> We would need a central server to generate the primary key for the table. But this can become a SPOF (Single Point of Failure) for the system.
        --> For auto-increment by 1 will definitely not work in a distributed system.
        --> We can only store the unique entries in a distributed manner as one query needs to wait for a running query to complete, get the unique id, increment that by 1 and then insert the next record. This is sequential and not efficient.

UUID:
    --> A better approach for the primary keys would be to
        -make it a concatenation of multiple variables, calculate those values and then use this.
        -This will be unique across the table and will be sequential as well.
     --> This is the idea behind UUID (Universally Unique Identifier).
--> UUID is a 128-bit number used to identify information in computer systems.
--> The UUID is generated using the current timestamp, the MAC address of the system, and a few other variables.
--> The UUID is unique across the table and is sequential as well.
--> The UUID is generated by the system and is not auto-incremented by 1.
UUID-7 is very popular nowadays to generate the primary key for the table. UUID-4 is the next popular one.

-> UUID as a String will be 36 characters long and will take up 36 bytes of space. (VARCHAR(36))
-> UUID as a byte array will be 16 bytes long and hence is stored as a BINARY(16) in the database.
We are going to use UUID as the primary key for the product table

** Using UUID in the project
1. Add the UUID dependency to the pom.xml
    <dependency>
        <groupId>com.fasterxml.uuid</groupId>
        <artifactId>java-uuid-generator</artifactId>
        <version>4.0.1</version>
    </dependency>
2. Add the UUIDGenerator class to the project
3. Add the @GeneratedValue(generator = "UUID") and @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator") annotations to the id field in the BaseEntity class.
4. Add the @Column(columnDefinition = "BINARY(16)", updatable = false, nullable = false) annotation to the id field in the BaseEntity class.
****The final implementation will look something like this:****
    @Id
    @GeneratedValue(generator = "navneet-uuid")
    @GenericGenerator(name = "navneet-uuid", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "binary(16)", nullable = false, updatable = false)
    private UUID uuid;
**** Relationship between entities ************************************
Inheritance and Associations are two different concepts that represent relationships between entities.

**Inheritance is a relationship between two entities where one entity is a child of the other entity.
Inheritance can be further classified into 3 categories:
    Single Table: All the entities are stored in a single table.
    Table Per Class: Each entity is stored in a separate table.
    Joined: The parent entity is stored in a separate table and the child entity is stored in a separate table.

**Association is a relationship between two entities where one entity is associated with the other entity.
Association can be further classified into 2 categories:
    Composition: The child entity cannot exist without the parent entity.
    Aggregation: The child entity can exist without the parent entity.

Details of Inheritance and Association:

**** Details of Composition and Aggregation: ********
Composition and aggregation are two types of relationships in object-oriented programming (OOP), and they are closely related to association:

--> Association:
    Definition: Association represents a bi-directional relationship between two classes, indicating that one class is related to another. This relationship can be one-to-one, one-to-many, or many-to-many.
    Example: Consider a Customer class and an Order class. A customer can place multiple orders, indicating a one-to-many association.

--> Composition:
    Definition: Composition is a stronger form of association. It implies a whole-part relationship where the existence of the whole is dependent on the existence of the parts. In composition, if the parent object is destroyed, all of its child objects are also destroyed.
    Example: A Car class may have an engine, wheels, and seats. If the car is destroyed, its engine, wheels, and seats are also removed.

--> Aggregation:
    Definition: Aggregation is a type of association that represents a whole-part relationship, but it is not as strict as composition. In aggregation, the parts can exist independently of the whole. If the parent object is destroyed, the child objects can still exist.
    Example: A Library class may contain Books. If the library closes, the books still exist; they can be moved to another library.

**** Association and Composition: ************************************************************************

    Composition is a more specific form of association. It represents a strong relationship where one class is composed of other classes. In this case, the composed objects are part of the whole and cannot exist independently.

    Example: A Library is composed of Books. If the library is destroyed, all associated books are also destroyed.

****** Association and Aggregation: ***********************************************************************
    Aggregation is also a form of association, but it represents a weaker relationship. It implies that objects are related, but they can exist independently of each other.
    Example: A Department has a list of Employees. If the department is dissolved, the employees can still exist and may join other departments.

****** Summary: ***************************************************************************************************
    Association is a general term for relationships between classes.
    Composition is a strong form of association where one class is composed of others, and the composed parts cannot exist without the whole.
    Aggregation is a weaker form of association where objects are related, but they can exist independently.
    In a UML diagram, association is typically represented by a line connecting classes, while composition is represented by a solid diamond shape on the side of the whole class, and aggregation is represented by an empty diamond shape.

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$   Class- 2: 15 Sep2023: Backend-10: Databases, Inheritance and Relations   $$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Representing Inheritance in Spring Data JPA
There are 4 types of inheritance in Spring Data JPA:
    1. Mapped SuperClass
    2. Table Per Class
    3. Joined Table
    4. Single Table

Mapped Superclass:
 --> Mapped Superclass is used when we want to share the common fields between the entities.
 --> We use the @MappedSuperclass annotation to represent the Mapped Superclass in the parent class.
 --> No table is created for the parent class.
 --> One table each is created for the child class which includes all the fields from the parent class and also some specific fields for the child class.
Mapped SuperCLass is typically used when the parent class is abstract and we want to share the common fields between the entities.

Table Per Class:
--> Similar to the Mapped Superclass, the Table Per Class is used when we want to share the common fields between the entities.
--> ORM creates a table for the parent class and a table for each child class.
--> When we query the parent class, the ORM queries the parent table and the child table both for the parent repository.
  --> ORM returns the parent class object with the common fields from the parent table and the specific fields from the child table.
  --> It uses the UNION ALL operator to combine the results from the parent table and the child table.
  [Union removes the duplicate records from the result set. Union All does not remove the duplicate records from the result set. Union All is faster than Union, and hence ORM uses Union All instead of Union to query the objects.]
--> When we query the child class, the ORM queries the child table only for the child repository.

Joined Table:
--> Similar to the Table Per Class, the Joined Table is used when we want to share the common fields between the entities.
--> ORM creates a table for the parent class and a table for each child class.
--> All of the attributes of the parent class are mapped to the parent table, and are not present in the child table.
--> Tables of thh child class have their own attributes and also the foreign key to the parent table.
--> Using the foreign key, the ORM joins the parent table and the child table to query the objects.
 --> It uses the JOIN operator to combine the results from the parent table and the child table.
 --> Each table only contains the attributes that are specific to that class.
 --> For any other attribute that is required from the other table, a 'JOIN' operation has to be performed. In such cases, the ORM queries the parent table and the child table both.

 Pros:
    To get all the users in the system, we can query the parent table only.
        --> Select name from user;
        This is a very efficient query as it does not need to join the parent table and the child table.
 Cons:
    To get the details of the child classes has become very inefficient.
        This query needs to join the parent table and the child table to get the details of the child classes in the form of a child object.
        --> Select * from user where user_type = 'ADMIN';
        This query needs to join the parent table and the child table to get the details of the child class (Admin table).

Single Table:
--> Similar to the Table Per Class, the Single Table is used when we want to share the common fields between the entities.
--> In the Single Table Inheritance,  ORM creates a single database table to represent all classes in an inheritance hierarchy. Each row in the table corresponds to an instance of one of the classes, and there is usually a discriminator column that indicates the type of each row.
--> There is a discriminator/differentiator column that indicates the type of each row.
Pros:
    --> No join is required to get the details of the child classes.
    --> Reading the data is very efficient and fast.
Cons:
    --> The table can become very large and can contain a lot of null values.
    --> It is impossible to have a not null constraint on the columns that are specific to the child classes.
    --> It is impossible to have a unique constraint on the columns that are specific to the child classes.

Choosing among the 4 inheritance methods:
Choosing the Right Strategy:

--> Mapped Superclass Inheritance is useful when you have shared attributes among multiple classes, but it doesn't create a corresponding table for the superclass.
 ** It is typically used when we have an abstract parent class and we want to share the common fields between the entities.

--> Joined Table Inheritance balances the strengths of Single Table and Table Per Class, but it requires more complex database schema and can lead to more complex queries.
    --> queries to get the object of the parent class is very fast, however details of the child classes are very inefficient as Join operation will be required.
    --. It has least amount of redundancy and null values, hence is usually the best option.

--> Single Table Inheritance is usually the simplest and most straightforward option, but it can lead to a lot of null values for attributes that don't apply to certain subclasses.

--> Table Per Class Inheritance provides a clean separation of classes into tables, but it can result in more complex queries due to the need for joins.
    --> Queries on object of child will be fast, however queries on object of parent attributes will be inefficient as Union All operation will be required on all the tables.
****** Implementing the Inheritance in Spring Data JPA: *******************
1. Mapped Superclass Inheritance:
@MappedSuperclass
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}
--> All the child classes will extend the User class and have the above 3 fields.
2. Single Table Inheritance:
@Getter@Setter
@Entity(name="st_user")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
--> In the above example, the discriminator column will be created by default with the name 'dtype'. --> st_user, st_mentor, st_student, st_ta.
--> Ideally we should have a discriminator column with the name 'user_type' instead of 'dtype'.
--> We can change the name and value of the discriminator column using the @DiscriminatorColumn annotation.
SO, the user class will now look like this:
@Getter@Setter
@Entity(name="st_user")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "user_type",
        discriminatorType = DiscriminatorType.INTEGER
    )
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
--> The discriminator column will now be created with the name 'user_type' and the value will be the ordinal value of the class.
--> The ordinal value of the class is the index of the class in the inheritance hierarchy.
--> The ordinal value of the User class is 0, the ordinal  the ordinal value of the Student class is 1, and the ordinal value of the TA class is 2 and value of the Mentor class is 3.
***********************************************************
3. Table Per Class Inheritance:
The User class will now look like this:
@Getter
@Setter
@ToString
@Entity(name = "tpc_user")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
If we do a findAll() on the User repository, we will get the following query:
#############################################
select
				user0_.id as id1_0_,
				user0_.email as email2_0_,
				user0_.name as name3_0_,
				user0_.dtype as dtype1_0_
		from
				tpc_user user0_
		union
		all select
				student0_.id as id1_0_,
				student0_.email as email2_0_,
				student0_.name as name3_0_,
				student0_.mentor_id as mentor_i4_0_
		from
				tpc_student student0_
		union
		all select
				mentor0_.id as id1_0_,
				mentor0_.email as email2_0_,
				mentor0_.name as name3_0_,
				mentor0_.salary as salary4_0_
		from
				tpc_mentor mentor0_
		union
		all select
				ta0_.id as id1_0_,
				ta0_.email as email2_0_,
				ta0_.name as name3_0_,
				ta0_.salary as salary4_0_
		from
				tpc_ta ta0_
		order by
				id1_0_
#############################################
So, the query is doing a union all on all the child tables for the user class, which is what we had discussed earlier.

4. Joined Table Inheritance:
The User class will now look like this:
@Getter
@Setter
@ToString
@Entity(name = "jt_user")
@Inheritance(strategy = InheritanceType.JOINED)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
And now we will just use the @PrimaryKeyJoinColumn(name = "user_id") annotation on the child classes to specify the foreign key to the parent table. By default, the foreign key is the primary key of the parent table, which is denoted by the name 'id'.
-- Having done this, we will only have individual fields values in the child tables and not the fields from the parent table. The fields from the parent table will be queried using the foreign key.
**********************************************
Cardinality:
Cardinality is the number of instances of an entity that can be associated with the number of instances of another entity.
There are 4 types of cardinality:
		1. One to One
		2. One to Many
		3. Many to One
		4. Many to Many
One to One:
		One to One is a relationship between two entities where one entity is associated with only one instance of another entity.
		Example: A User has one Passport, one PAN Card, one Aadhaar Card etc.

One to Many:
		One to Many is a relationship between two entities where one entity is associated with many instances of another entity.
		Example: A User has many Addresses, many Phone Numbers, many Bank Accounts etc.

Many to One:
		Many to One is a relationship between two entities where many instances of one entity are associated with one instance of another entity.
		Example: Many Users have one pin code, one nationality etc.

Many to Many:
		Many to Many is a relationship between two entities where many instances of one entity are associated with many instances of another entity.
		Example: Many Users have many Roles, many Users have many Permissions etc.
##########
In our SpringBoot project, we have 2 entities: Product and Category.
1 product has 1 category
1 category has many products
So,the cardinality between the product and the category entities is One to Many.
##########
In Product, we define the relationship as follows:
    @JoinColumn(name = "category_id")
    @ManyToOne
    private Category category;

In Category, we define the relationship as follows:
			@OneToMany
		private List<Product> products;
##########
Between 2 different entities, there can be multiple relationships.
For example, in whatsapp, one user can be creator/admin/member .. so this demonstrates 3 different relationships between a user and a group.
	1 user can be a member of many groups
	1 group can have many users
		User: Group --> M:N

	1 user can be a creator of many groups
	1 group can have only 1 creator
		User: Group --> 1:M

	1 user can be an admin of many groups
	1 group can have many admins
		User: Group --> M:N

So, we can see that between 2 entities, there can be multiple relationships.

############################################
If we use the mapping between Category and Products in the way mentioned above, Spring Data JPA will create a new table called product_category to store the relationship between the 2 entities. This is called a Join Table.
########
This is because Spring thinks that there are 2 different relationships between product and categories.
	1. One to Many (Category to Product)
	2. Many to Many (Category to Product)
It creates a category id in the product table for the 1:M mapping.
It also creates a separate table called categories_products to store the M:N mapping.

This is not what we want. We want to have only 1 relationship between the 2 entities, which is 1:M.

So, we need to tell Spring Data JPA that there is only 1 relationship between the 2 entities- Category and Products, which is 1:M.

To do this, we can use the JPA Buddy plugin's Owning side feature to mark that the Category owns the Product or rather there can be many products tha belong to one category.

So, we go to the Category entity mark that the Category owns the Product. Due to this, the JPA plugin will add the following annotation to the Category entity:

** If there is a Many to One relationship between 2 entities, then the entity that represents the One side of the cardinality will have the  @OneToMany annotation and just adjacent to it, we will mark mapped by the entity that represents the One side of the cardinality.

So, in our case, the Category entity represents the One side of the cardinality and the Product entity represents the Many side of the cardinality.

    private String name;
    @OneToMany(mappedBy = "category")
    private List<Product> products;

So, we have marked that the Category entity owns the Product entity and there can be many products that belong to one category.

*************************************************************************
We can do this by using the mappedBy attribute in the @OneToMany annotation.

########
When a relationship is defined between 2 entities, in the entity that represents 1 of the M:1 Relationship, we use the (mappedBy = "entityName") attribute in the @OneToMany annotation.
In our case, the relationship is between Product and Category is M:1, Product being the M side of the cardinality and Category being 1.

So, in the Category entity, we will use the following annotation:
	@OneToMany(mappedBy = "category")
	private List<Product> products;

And in the Product entity, we will use the following annotation:
	@ManyToOne
  private Category category;

**********************************************
Implementing Product and Category Repositories and performing CRUD operations
We will create 2 repositories:
	1. ProductRepository
	2. CategoryRepository
	and have them extend the JpaRepository interface.
1. Create the ProductRepository interface
	@Repository
		public interface ProductRepository
			extends JpaRepository<Product, UUID> {
	}
2. Create the CategoryRepository interface
	@Repository
	public interface CategoryRepository
					extends JpaRepository<Category, UUID> {
	}

	We will now use these repositories in the ProductServiceApplication class to perform CRUD operations on the Product and Category entities.
	We will create a category and save it in the database using the category repo.
	We will then create a product for this category and save it in the database using the product repo.

			Category category = new Category();
			category.setName("Apple Devices");
			Category savedCategory = categoryRepository.save(category);

			Product product = new Product();
			product.setTitle("iPhone 15 Pro");
			product.setDescription("The best iPhone Ever");
			product.setCategory(savedCategory);

			productRepository.save(product);

	Then we will demonstrate a Read Operation by fetching the saved category from the database and then fetching all the products for the category from the database.

			Optional<Category> optionalCategory1 = categoryRepository.findById(UUID.fromString("d818e0c7-8e39-45da-8ad9-20a607784389"));
			if(!optionalCategory1.isEmpty()) {
				Category category1 = optionalCategory1.get();
				System.out.println("Category name is: " + category1.getName());
				System.out.println("Printing all products in the category");
				Thread.sleep(1000);
				for (Product product1: category1.getProducts()) {
        		System.out.println(product1.getTitle());
        		System.out.println(product1.getDescription());
        }
			}
			else {
				System.out.println("Category not found");
			}
		}
********
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$ Class- 3: 18 Sep2023: Backend-11: Representing Cardinalities, Fetch_Types $$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
We have implemented a M:1 relationship between the Product and Category entities.
We will now represent One To One and Many to Many cardinalities in our project.
* Products can have many to many relationship with orders.

* we will create a new entity called Order and create a many to many relationship between the Product and Order entities.

* We will also create a one to one relationship between the Product and Price entities.

* Let's put a default value to currency field using the @Column annotation.
		@Column(columnDefinition = "varchar(3) default 'INR'")

The Price entity will look like this:
import jakarta.persistence.Entity; import lombok.Getter; import lombok.Setter;

@Getter@ Setter
@Entity(name="prices")
public class Price extends BaseModel{
    @Column(columnDefinition = "varchar(3) default 'INR'")
    private String currency;
    private double price;
}

And now our Product entity will also contain a Price field:
		@OneToOne
		private Price price;

*********************************************
		So we have represented implemented all the 4 relationships between entities:
		1. One to One
		2. Many to One
		  Class Product{
		    @ManyToOne
        private Category category;
        @OneToOne
        private Price price;
      }
    3. One to Many
    	Class Category{
				@OneToMany(mappedBy = "category")
				private List<Product> products;
			}
		4. Many to Many
			Class Order{
				@ManyToMany
				private List<Product> products;
			}
And if ever we need to represent a relationship from both the entities, we can use a MappedBy annotation.
***********************************************************
We will create a price repository and create and save a price object.
public interface PriceRepository extends JpaRepository<Price,Long> {
}

And then in the ProductServiceApplication class, we will create a price object and save it in the database.

* We can also change the column header for the mapping table using the @JoinTable annotation.
		@JoinTable(name = "product_orders",
				joinColumns = @JoinColumn(name = "product_id"),
				inverseJoinColumns = @JoinColumn(name = "order_id")
		)
		private List<Order> orders;
**** Cascades ****************************************************************
Cascades are used to propagate the state changes from one entity to another entity.
Now, we have an implementation of a Product such that in order to save a product, we need to save the category first and then save the product.
We will now implement a cascade such that when we want to save a product, we don't need to save the category and order in advance.
We do so by using the @Cascade annotation and using the CascadeType.Persist value.
		@ManyToOne(cascade = CascadeType.PERSIST)
		private Category category;
		@OneToOne(cascade = CascadeType.PERSIST)
		private Price price;
##########
 If we delete a product, we want to delete the price as well.
 We can do so by using the CascadeType.REMOVE value.
  So now in our Product entity, we will have the following annotations for the price field
		    @OneToOne (cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
        private Price price;

 Now, if we delete a product, the price will also be deleted.
##########
