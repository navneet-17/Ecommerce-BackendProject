$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$ class-9:11Sep Intro To Spring Data JPA, ORM, Hibernate,JDBC, Entities, UUIDs $$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$

Adding the database connection to the project
1. Add the Spring Data JPA dependency to the pom.xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

2. Add the MySql dependency to the pom.xml
        <dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>

3. Add the database connection properties to the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
    spring.datasource.username=springuser
    spring.datasource.password=ThePassword
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

4. Add the database config in mysql workbench:
    create database scalerbackendproductservice;
    create user scalerbackendproductservice;
    grant all privileges on scalerbackendproductservice.* to scalerbackendproductservice;

5. Update the MYSQL host and user details in the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://localhost:3306/scalerbackendproductservice
    spring.datasource.username=scalerbackendproductservice
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

****** TODO: Mapped Superclass ******************************
1. Create a new class called BaseEntity
2. Add the @MappedSuperclass annotation to the BaseEntity class
3. Add the @Id and @GeneratedValue(strategy = GenerationType.IDENTITY) annotations to the id field

 ****UUID*****************************************
Let's look at the data type options for generating the primary key
*String:
  Having the Primary Keys as String is a terrible idea.
 -> Whenever we are storing a table in a particular database, for the primary key, an index is also created usually.
 --> The index is used to quickly search for a particular record in the table. (The index is stored in a data structure called a B-Tree.)
 --> However, the B-Tree data structure is not efficient when the data type is String. This indexing for String can be huge in itself and can significantly slow down the queries.
    --> The String data type is not efficient for the primary key and is almost always a terrible idea.

* Integer/Long:
    -> The Integer/Long data type is efficient for the primary key.

    *Benefits of the integer/long primary key:
        1. The primary key is auto generated by the database
        2. The primary key is unique across the table
        3. The primary key is sequential
        4. The Integer/Long data type is efficient for the primary key

    *Drawbacks of the integer/long primary key:
    --> However, the Integer/Long data type has a few drawbacks.
        --> When the systems are distributed, the Integer/Long data type is not efficient.
        --> When the systems are distributed, the Integer/Long data type is not unique neither sequential across the table.
        --> We would need a central server to generate the primary key for the table. But this can become a SPOF (Single Point of Failure) for the system.
        --> For auto-increment by 1 will definitely not work in a distributed system.
        --> We can only store the unique entries in a distributed manner as one query needs to wait for a running query to complete, get the unique id, increment that by 1 and then insert the next record. This is sequential and not efficient.

UUID:
    --> A better approach for the primary keys would be to
        -make it a concatenation of multiple variables, calculate those values and then use this.
        -This will be unique across the table and will be sequential as well.
     --> This is the idea behind UUID (Universally Unique Identifier).
--> UUID is a 128-bit number used to identify information in computer systems.
--> The UUID is generated using the current timestamp, the MAC address of the system, and a few other variables.
--> The UUID is unique across the table and is sequential as well.
--> The UUID is generated by the system and is not auto-incremented by 1.
UUID-7 is very popular nowadays to generate the primary key for the table. UUID-4 is the next popular one.

-> UUID as a String will be 36 characters long and will take up 36 bytes of space. (VARCHAR(36))
-> UUID as a byte array will be 16 bytes long and hence is stored as a BINARY(16) in the database.
We are going to use UUID as the primary key for the product table

** Using UUID in the project
1. Add the UUID dependency to the pom.xml
    <dependency>
        <groupId>com.fasterxml.uuid</groupId>
        <artifactId>java-uuid-generator</artifactId>
        <version>4.0.1</version>
    </dependency>
2. Add the UUIDGenerator class to the project
3. Add the @GeneratedValue(generator = "UUID") and @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator") annotations to the id field in the BaseEntity class.
4. Add the @Column(columnDefinition = "BINARY(16)", updatable = false, nullable = false) annotation to the id field in the BaseEntity class.
****The final implementation will look something like this:****
    @Id
    @GeneratedValue(generator = "navneet-uuid")
    @GenericGenerator(name = "navneet-uuid", strategy = "uuid2")
    @Column(name = "id", columnDefinition = "binary(16)", nullable = false, updatable = false)
    private UUID uuid;
**** Relationship between entities ************************************
Inheritance and Associations are two different concepts that represent relationships between entities.

**Inheritance is a relationship between two entities where one entity is a child of the other entity.
Inheritance can be further classified into 3 categories:
    Single Table: All the entities are stored in a single table.
    Table Per Class: Each entity is stored in a separate table.
    Joined: The parent entity is stored in a separate table and the child entity is stored in a separate table.

**Association is a relationship between two entities where one entity is associated with the other entity.
Association can be further classified into 2 categories:
    Composition: The child entity cannot exist without the parent entity.
    Aggregation: The child entity can exist without the parent entity.

Details of Inheritance and Association:

**** Details of Composition and Aggregation: ********
Composition and aggregation are two types of relationships in object-oriented programming (OOP), and they are closely related to association:

--> Association:
    Definition: Association represents a bi-directional relationship between two classes, indicating that one class is related to another. This relationship can be one-to-one, one-to-many, or many-to-many.
    Example: Consider a Customer class and an Order class. A customer can place multiple orders, indicating a one-to-many association.

--> Composition:
    Definition: Composition is a stronger form of association. It implies a whole-part relationship where the existence of the whole is dependent on the existence of the parts. In composition, if the parent object is destroyed, all of its child objects are also destroyed.
    Example: A Car class may have an engine, wheels, and seats. If the car is destroyed, its engine, wheels, and seats are also removed.

--> Aggregation:
    Definition: Aggregation is a type of association that represents a whole-part relationship, but it is not as strict as composition. In aggregation, the parts can exist independently of the whole. If the parent object is destroyed, the child objects can still exist.
    Example: A Library class may contain Books. If the library closes, the books still exist; they can be moved to another library.

**** Association and Composition: ************************************************************************

    Composition is a more specific form of association. It represents a strong relationship where one class is composed of other classes. In this case, the composed objects are part of the whole and cannot exist independently.

    Example: A Library is composed of Books. If the library is destroyed, all associated books are also destroyed.

****** Association and Aggregation: ***********************************************************************
    Aggregation is also a form of association, but it represents a weaker relationship. It implies that objects are related, but they can exist independently of each other.
    Example: A Department has a list of Employees. If the department is dissolved, the employees can still exist and may join other departments.

****** Summary: ***************************************************************************************************
    Association is a general term for relationships between classes.
    Composition is a strong form of association where one class is composed of others, and the composed parts cannot exist without the whole.
    Aggregation is a weaker form of association where objects are related, but they can exist independently.
    In a UML diagram, association is typically represented by a line connecting classes, while composition is represented by a solid diamond shape on the side of the whole class, and aggregation is represented by an empty diamond shape.

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$   Class- 2: 15 Sep2023: Backend-10: Databases, Inheritance and Relations   $$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Representing Inheritance in Spring Data JPA
There are 4 types of inheritance in Spring Data JPA:
    1. Mapped SuperClass
    2. Table Per Class
    3. Joined Table
    4. Single Table

Mapped Superclass:
 --> Mapped Superclass is used when we want to share the common fields between the entities.
 --> We use the @MappedSuperclass annotation to represent the Mapped Superclass in the parent class.
 --> No table is created for the parent class.
 --> One table each is created for the child class which includes all the fields from the parent class and also some specific fields for the child class.
Mapped SuperCLass is typically used when the parent class is abstract and we want to share the common fields between the entities.

Table Per Class:
--> Similar to the Mapped Superclass, the Table Per Class is used when we want to share the common fields between the entities.
--> ORM creates a table for the parent class and a table for each child class.
--> When we query the parent class, the ORM queries the parent table and the child table both for the parent repository.
  --> ORM returns the parent class object with the common fields from the parent table and the specific fields from the child table.
  --> It uses the UNION ALL operator to combine the results from the parent table and the child table.
  [Union removes the duplicate records from the result set. Union All does not remove the duplicate records from the result set. Union All is faster than Union, and hence ORM uses Union All instead of Union to query the objects.]
--> When we query the child class, the ORM queries the child table only for the child repository.

Joined Table:
--> Similar to the Table Per Class, the Joined Table is used when we want to share the common fields between the entities.
--> ORM creates a table for the parent class and a table for each child class.
--> All of the attributes of the parent class are mapped to the parent table, and are not present in the child table.
--> Tables of thh child class have their own attributes and also the foreign key to the parent table.
--> Using the foreign key, the ORM joins the parent table and the child table to query the objects.
 --> It uses the JOIN operator to combine the results from the parent table and the child table.
 --> Each table only contains the attributes that are specific to that class.
 --> For any other attribute that is required from the other table, a 'JOIN' operation has to be performed. In such cases, the ORM queries the parent table and the child table both.

 Pros:
    To get all the users in the system, we can query the parent table only.
        --> Select name from user;
        This is a very efficient query as it does not need to join the parent table and the child table.
 Cons:
    To get the details of the child classes has become very inefficient.
        This query needs to join the parent table and the child table to get the details of the child classes in the form of a child object.
        --> Select * from user where user_type = 'ADMIN';
        This query needs to join the parent table and the child table to get the details of the child class (Admin table).

Single Table:
--> Similar to the Table Per Class, the Single Table is used when we want to share the common fields between the entities.
--> In the Single Table Inheritance,  ORM creates a single database table to represent all classes in an inheritance hierarchy. Each row in the table corresponds to an instance of one of the classes, and there is usually a discriminator column that indicates the type of each row.
--> There is a discriminator/differentiator column that indicates the type of each row.
Pros:
    --> No join is required to get the details of the child classes.
    --> Reading the data is very efficient and fast.
Cons:
    --> The table can become very large and can contain a lot of null values.
    --> It is impossible to have a not null constraint on the columns that are specific to the child classes.
    --> It is impossible to have a unique constraint on the columns that are specific to the child classes.

Choosing among the 4 inheritance methods:
Choosing the Right Strategy:

--> Mapped Superclass Inheritance is useful when you have shared attributes among multiple classes, but it doesn't create a corresponding table for the superclass.
 ** It is typically used when we have an abstract parent class and we want to share the common fields between the entities.

--> Joined Table Inheritance balances the strengths of Single Table and Table Per Class, but it requires more complex database schema and can lead to more complex queries.
    --> queries to get the object of the parent class is very fast, however details of the child classes are very inefficient as Join operation will be required.
    --. It has least amount of redundancy and null values, hence is usually the best option.

--> Single Table Inheritance is usually the simplest and most straightforward option, but it can lead to a lot of null values for attributes that don't apply to certain subclasses.

--> Table Per Class Inheritance provides a clean separation of classes into tables, but it can result in more complex queries due to the need for joins.
    --> Queries on object of child will be fast, however queries on object of parent attributes will be inefficient as Union All operation will be required on all the tables.
****** Implementing the Inheritance in Spring Data JPA: *******************
1. Mapped Superclass Inheritance:
@MappedSuperclass
public class User {
    @Id
    private Long id;
    private String name;
    private String email;
}
--> All the child classes will extend the User class and have the above 3 fields.
2. Single Table Inheritance:
@Getter@Setter
@Entity(name="st_user")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
--> In the above example, the discriminator column will be created by default with the name 'dtype'. --> st_user, st_mentor, st_student, st_ta.
--> Ideally we should have a discriminator column with the name 'user_type' instead of 'dtype'.
--> We can change the name and value of the discriminator column using the @DiscriminatorColumn annotation.
SO, the user class will now look like this:
@Getter@Setter
@Entity(name="st_user")
@Inheritance(strategy = InheritanceType.SINGLE_TABLE)
@DiscriminatorColumn(name = "user_type",
        discriminatorType = DiscriminatorType.INTEGER
    )
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
--> The discriminator column will now be created with the name 'user_type' and the value will be the ordinal value of the class.
--> The ordinal value of the class is the index of the class in the inheritance hierarchy.
--> The ordinal value of the User class is 0, the ordinal  the ordinal value of the Student class is 1, and the ordinal value of the TA class is 2 and value of the Mentor class is 3.
***********************************************************
3. Table Per Class Inheritance:
The User class will now look like this:
@Getter
@Setter
@ToString
@Entity(name = "tpc_user")
@Inheritance(strategy = InheritanceType.TABLE_PER_CLASS)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
If we do a findAll() on the User repository, we will get the following query:
#############################################
select
				user0_.id as id1_0_,
				user0_.email as email2_0_,
				user0_.name as name3_0_,
				user0_.dtype as dtype1_0_
		from
				tpc_user user0_
		union
		all select
				student0_.id as id1_0_,
				student0_.email as email2_0_,
				student0_.name as name3_0_,
				student0_.mentor_id as mentor_i4_0_
		from
				tpc_student student0_
		union
		all select
				mentor0_.id as id1_0_,
				mentor0_.email as email2_0_,
				mentor0_.name as name3_0_,
				mentor0_.salary as salary4_0_
		from
				tpc_mentor mentor0_
		union
		all select
				ta0_.id as id1_0_,
				ta0_.email as email2_0_,
				ta0_.name as name3_0_,
				ta0_.salary as salary4_0_
		from
				tpc_ta ta0_
		order by
				id1_0_
#############################################
So, the query is doing a union all on all the child tables for the user class, which is what we had discussed earlier.

4. Joined Table Inheritance:
The User class will now look like this:
@Getter
@Setter
@ToString
@Entity(name = "jt_user")
@Inheritance(strategy = InheritanceType.JOINED)
public class User {
    @Id
    @GeneratedValue(strategy = GenerationType.AUTO)
    private Long id;
    private String name;
    private String email;
}
And now we will just use the @PrimaryKeyJoinColumn(name = "user_id") annotation on the child classes to specify the foreign key to the parent table. By default, the foreign key is the primary key of the parent table, which is denoted by the name 'id'.
-- Having done this, we will only have individual fields values in the child tables and not the fields from the parent table. The fields from the parent table will be queried using the foreign key.
**********************************************
Cardinality:
Cardinality is the number of instances of an entity that can be associated with the number of instances of another entity.
There are 4 types of cardinality:
		1. One to One
		2. One to Many
		3. Many to One
		4. Many to Many
One to One:
		One to One is a relationship between two entities where one entity is associated with only one instance of another entity.
		Example: A User has one Passport, one PAN Card, one Aadhaar Card etc.

One to Many:
		One to Many is a relationship between two entities where one entity is associated with many instances of another entity.
		Example: A User has many Addresses, many Phone Numbers, many Bank Accounts etc.

Many to One:
		Many to One is a relationship between two entities where many instances of one entity are associated with one instance of another entity.
		Example: Many Users have one pin code, one nationality etc.

Many to Many:
		Many to Many is a relationship between two entities where many instances of one entity are associated with many instances of another entity.
		Example: Many Users have many Roles, many Users have many Permissions etc.
##########
In our SpringBoot project, we have 2 entities: Product and Category.
1 product has 1 category
1 category has many products
So,the cardinality between the product and the category entities is One to Many.
##########
In Product, we define the relationship as follows:
    @JoinColumn(name = "category_id")
    @ManyToOne
    private Category category;

In Category, we define the relationship as follows:
			@OneToMany
		private List<Product> products;
##########
Between 2 different entities, there can be multiple relationships.
For example, in whatsapp, one user can be creator/admin/member .. so this demonstrates 3 different relationships between a user and a group.
	1 user can be a member of many groups
	1 group can have many users
		User: Group --> M:N

	1 user can be a creator of many groups
	1 group can have only 1 creator
		User: Group --> 1:M

	1 user can be an admin of many groups
	1 group can have many admins
		User: Group --> M:N

So, we can see that between 2 entities, there can be multiple relationships.

############################################
If we use the mapping between Category and Products in the way mentioned above, Spring Data JPA will create a new table called product_category to store the relationship between the 2 entities. This is called a Join Table.
########
This is because Spring thinks that there are 2 different relationships between product and categories.
	1. One to Many (Category to Product)
	2. Many to Many (Category to Product)
It creates a category id in the product table for the 1:M mapping.
It also creates a separate table called categories_products to store the M:N mapping.

This is not what we want. We want to have only 1 relationship between the 2 entities, which is 1:M.

So, we need to tell Spring Data JPA that there is only 1 relationship between the 2 entities- Category and Products, which is 1:M.

To do this, we can use the JPA Buddy plugin's Owning side feature to mark that the Category owns the Product or rather there can be many products tha belong to one category.

So, we go to the Category entity mark that the Category owns the Product. Due to this, the JPA plugin will add the following annotation to the Category entity:

** If there is a Many to One relationship between 2 entities, then the entity that represents the One side of the cardinality will have the  @OneToMany annotation and just adjacent to it, we will mark mapped by the entity that represents the One side of the cardinality.

So, in our case, the Category entity represents the One side of the cardinality and the Product entity represents the Many side of the cardinality.

    private String name;
    @OneToMany(mappedBy = "category")
    private List<Product> products;

So, we have marked that the Category entity owns the Product entity and there can be many products that belong to one category.

*************************************************************************
We can do this by using the mappedBy attribute in the @OneToMany annotation.

########
When a relationship is defined between 2 entities, in the entity that represents 1 of the M:1 Relationship, we use the (mappedBy = "entityName") attribute in the @OneToMany annotation.
In our case, the relationship is between Product and Category is M:1, Product being the M side of the cardinality and Category being 1.

So, in the Category entity, we will use the following annotation:
	@OneToMany(mappedBy = "category")
	private List<Product> products;

And in the Product entity, we will use the following annotation:
	@ManyToOne
  private Category category;

**********************************************
Implementing Product and Category Repositories and performing CRUD operations
We will create 2 repositories:
	1. ProductRepository
	2. CategoryRepository
	and have them extend the JpaRepository interface.
1. Create the ProductRepository interface
	@Repository
		public interface ProductRepository
			extends JpaRepository<Product, UUID> {
	}
2. Create the CategoryRepository interface
	@Repository
	public interface CategoryRepository
					extends JpaRepository<Category, UUID> {
	}

	We will now use these repositories in the ProductServiceApplication class to perform CRUD operations on the Product and Category entities.
	We will create a category and save it in the database using the category repo.
	We will then create a product for this category and save it in the database using the product repo.

			Category category = new Category();
			category.setName("Apple Devices");
			Category savedCategory = categoryRepository.save(category);

			Product product = new Product();
			product.setTitle("iPhone 15 Pro");
			product.setDescription("The best iPhone Ever");
			product.setCategory(savedCategory);

			productRepository.save(product);

	Then we will demonstrate a Read Operation by fetching the saved category from the database and then fetching all the products for the category from the database.

			Optional<Category> optionalCategory1 = categoryRepository.findById(UUID.fromString("d818e0c7-8e39-45da-8ad9-20a607784389"));
			if(!optionalCategory1.isEmpty()) {
				Category category1 = optionalCategory1.get();
				System.out.println("Category name is: " + category1.getName());
				System.out.println("Printing all products in the category");
				Thread.sleep(1000);
				for (Product product1: category1.getProducts()) {
        		System.out.println(product1.getTitle());
        		System.out.println(product1.getDescription());
        }
			}
			else {
				System.out.println("Category not found");
			}
		}
********
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$ Class- 3: 18 Sep2023: Backend-11: Representing Cardinalities, Fetch_Types $$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
We have implemented a M:1 relationship between the Product and Category entities.
We will now represent One To One and Many to Many cardinalities in our project.
* Products can have many to many relationship with orders.

* we will create a new entity called Order and create a many to many relationship between the Product and Order entities.

* We will also create a one to one relationship between the Product and Price entities.

* Let's put a default value to currency field using the @Column annotation.
		@Column(columnDefinition = "varchar(3) default 'INR'")

The Price entity will look like this:
import jakarta.persistence.Entity; import lombok.Getter; import lombok.Setter;

@Getter@ Setter
@Entity(name="prices")
public class Price extends BaseModel{
    @Column(columnDefinition = "varchar(3) default 'INR'")
    private String currency;
    private double price;
}

And now our Product entity will also contain a Price field:
		@OneToOne
		private Price price;

*********************************************
		So we have represented implemented all the 4 relationships between entities:
		1. One to One
		2. Many to One
		  Class Product{
		    @ManyToOne
        private Category category;
        @OneToOne
        private Price price;
      }
    3. One to Many
    	Class Category{
				@OneToMany(mappedBy = "category")
				private List<Product> products;
			}
		4. Many to Many
			Class Order{
				@ManyToMany
				private List<Product> products;
			}
And if ever we need to represent a relationship from both the entities, we can use a MappedBy annotation.
***********************************************************
We will create a price repository and create and save a price object.
public interface PriceRepository extends JpaRepository<Price,Long> {
}

And then in the ProductServiceApplication class, we will create a price object and save it in the database.

* We can also change the column header for the mapping table using the @JoinTable annotation.
		@JoinTable(name = "product_orders",
				joinColumns = @JoinColumn(name = "product_id"),
				inverseJoinColumns = @JoinColumn(name = "order_id")
		)
		private List<Order> orders;
**** Cascades ****************************************************************
Cascades are used to propagate the state changes from one entity to another entity.
Now, we have an implementation of a Product such that in order to save a product, we need to save the category first and then save the product.
We will now implement a cascade such that when we want to save a product, we don't need to save the category and order in advance.
We do so by using the @Cascade annotation and using the CascadeType.Persist value.
		@ManyToOne(cascade = CascadeType.PERSIST)
		private Category category;
		@OneToOne(cascade = CascadeType.PERSIST)
		private Price price;
##########
 If we delete a product, we want to delete the price as well.
 We can do so by using the CascadeType.REMOVE value.
  So now in our Product entity, we will have the following annotations for the price field
		    @OneToOne (cascade = {CascadeType.PERSIST, CascadeType.REMOVE})
        private Price price;

 Now, if we delete a product, the price will also be deleted.
**** JPA Queries **************
* Repositories are the class that allow us to access the database where our  models are stored.
* We can use the repositories to perform CRUD operations on the database.
* Every database operation is a query.
* Every query will have to be written in the repository or in order words every query will be a part of a repository.
* Spring Data JPA creates the queries for us based on the method names that we define in the repository.
** The Spring Data JPA queries are further divided into 2 parts:
1. Subject
2. Predicate
** The Subject is the entity on which we are performing the query.
** The Predicate is the condition that we are applying on the Subject.

Select * from product where title = 'iPhone 15 Pro';
In the above query, the Subject is the Product entity and the Predicate is the condition that the title of the product should be 'iPhone 15 Pro'.

Spring Data JPA query for the above query will be:
findByTitle(String title);

We can also use multiple predicates in the query.
-- Get the product by title and price:
     Product findByTitleAndPrice_Price(String title, Double price);

We can get multiple products using the findAll method.
-- Get all products by currency
     List<Product> findAllByPrice_Currency(String currency);

Implementing the above queries in the Application class:

			List<Product> products = productRepository.findAllByPrice_Currency("INR");
			System.out.println("Printing all products with currency INR");
			for (Product product1: products) {
				System.out.println(product1.getTitle());
				System.out.print(" "+product1.getDescription());
				System.out.print(" "+product1.getPrice().getCurrency());
				System.out.print(" "+product1.getPrice().getPrice());
			}
		}
Output --> Printing all products with currency INR
iPhone 15 Pro The best iPhone Ever INR 100000.0
 The best iPhone Ever INR 100000.0iPhone 15 Pro
 The best iPhone Ever INR 100000.0iPhone 15 Pro
 The best iPhone Ever INR 100000.0iPhone 15 Pro
 The best iPhone Ever INR 100000.0iPhone 15 Pro
 ***********************************************************************

how exactly is this working?
Spring Data JPA is using Hibernate to create the queries for us.
Hibernate is an ORM (Object Relational Mapping) tool which internally uses JDBC to connect to the database.

let's break down the flow for the query productRepository.findAllByPrice_Currency("INR") step by step:
1. Spring Data JPA will use method name query derivation to automatically generate a query based on the method name.

2. Spring Data JPA will parse the method name and will generate a JPQL (Java Persistence Query Language) query based on the method name.
	  SELECT p FROM Product p WHERE p.price.currency = 'INR'

3. Spring Data JPA will then use Hibernate to execute the query.
		* Hibernate is the Object-Relational Mapping (ORM) framework used by Spring Data JPA.
		* Hibernate is an implementation of the Java Persistence API (JPA).

4. 	Hibernate takes the JPQL query and translates it into SQL. The SQL query might look something like this:
		SELECT p.id, p.title, p.description, p.category_id, p.price_id
		FROM product p
		INNER JOIN price pr ON p.price_id = pr.id
		WHERE pr.currency = 'INR'

5. Hibernate then uses JDBC to execute the SQL query on the database.
		* The JDBC (Java Database Connectivity) driver is a platform-independent interface for connecting Java applications to a database.
		* It handles the communication between the Java application and the MySQL database.

6. The MySQL database executes the SQL query and returns the results to the JDBC driver.

7. Hibernate Result Set Mapping:
   	Hibernate takes the results from the database and converts them back into Java objects.

8. Hibernate returns the Java objects to Spring Data JPA.

9. Spring Data JPA Repository:
   Finally, Spring Data JPA takes the Java objects representing the records and provides them back to our application.

**************************************

Some more examples of the JPA queries:
** Count the number of products in the database for a particular currency:
		Long count = productRepository.countByPrice_Currency("INR");
		System.out.println("Number of products with currency INR: " + count);
**************************************

* We can also write custom queries in the repository.
To do so, we need to use the @Query annotation.

@Query("select p from Product p where title = :title ", nativeQuery = true)
List<Product> findProductByTitle(@Param("title") String title);

And then call this from the Application class:
List<Product> products1 = productRepository.findAllProductsByTitle("iPhone 15 Pro");
			System.out.println("Printing all products with title iPhone 15 Pro");
			for (Product product1: products1) {
				System.out.println(product1.getTitle());
				System.out.print(" "+product1.getDescription());
				System.out.print(" "+product1.getPrice().getCurrency());
				System.out.print(" "+product1.getPrice().getPrice());
			}
*****************************************************************************************************************
Native Queries:
* We can also write native queries in the repository.

We typically create a native query when we want to use a database-specific feature that is not supported by JPQL.
--> Let's say if we have to use a MySQL specific function, then we will have to use a native query.
--> Or if there's a chance that we will need to migrate to a different database in future which has a different query language support, we write all the queries in another file as place holders and then use these in our actual repository files .
--> This helps us in migrating to a different database in future, where we can just change the values of the placeholders and the queries will work fine.

example:
	We will create a CustomQueries interface file and create native queries in it.

	public interface CustomQueries {
		    String FIND_ALL_BY_TITLE = "select * from product join product_orders " +
                "on product.id = product_orders.product_id where title = :iPhone 15 Pro";
	}

	And then we will use this query in the ProductRepository file.
	    @Query(value = CustomQueries.FIND_ALL_BY_TITLE, nativeQuery = true)
      List<Product> findAllByTitle(String naman);

******** Hibernate query Language (HQL) *********
Hibernate Query Language (HQL) is an object-oriented query language, similar to SQL, but instead of operating on tables and columns, HQL works with persistent objects and their properties.
HQL queries are translated by Hibernate into conventional SQL queries, which in turns perform action on database.

Below will be the HQL query for the above native query:
    @Query("select Product from Product where Product.price.currency = :currency and Product.title = :naman")
    List<Product> doSomething(String naman, String currency);

--> HQL is database independent, as everything that we query will be in terms of the entities and not the tables.
-> We can name it anything we want, like we used doSomething here.

Our approach in real-world should be prioritized as follows to fetch data from the database:
1. Use the Spring Data JPA method name query derivation to automatically generate a query based on the method name.
2. Use the Hibernate Query Language (HQL) to write a query (Gives a compile time safety).
3. Use the Native Query to write a query, MySQl specific or whatever db we are using.
*************************************************************************************

$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
$$$$ Class- 4: 20 Sep2023: Backend-12: Databases: N + 1 Problem, Fetch Type, Fetch Modes $$$$
$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$$
Lazy v/s Eager Fetching:
* By default, all the relationships in Spring Data JPA are lazy.
* Lazy fetching means that the related entities are not loaded until they are explicitly requested.
* Eager fetching means that the related entities are loaded immediately when the parent entity is loaded.

*Consider the following example:
  We have a Product entity and a Category entity.
  The Product entity has a Many to One relationship with the Category entity.
  --> If we want to fetch the details of a category, we query on the category table with the category id.
  --> Now, these category may have all the products that belong to that category, but we do not want to fetch all the products for that category, we just want to fetch the specific category details.

 So, these products under the category will be lazing loaded by default, i.e. they will be loaded only when we explicitly request for them, and not return every time when we query a category.

 The query will look something like this:
  	select * from category where id = 1;

On the contrary, imagine if all the products under the category are eagerly loaded when we query for a specific category using its id, then the query will look something like this:
		select * from category c join product p on c.id = p.category_id where c.id = 1;

Let's lok at the Cons and Pros of Such Eager Loading:

CONS:
- The query will be very slow as it will be joining the category table and the product table.
- The query will return a lot of duplicate data as the category details will be repeated for every product under the category.
- The query will return a lot of null values as the product table will not have the category details for every product.
- A lot of memory will be wasted in storing the duplicate data and the null values.

PROS:
- There will be only 1 database call to fetch the category details and the product details.
- The query will be very fast as it will be just querying the category table.
- The query will return the category details along with the product details in a single query.

Spring Data JPA provides us with 2 ways to fetch the related entities:
1. Fetch Type
2. Fetch Mode

Fetch Type:
	Fetch Type is used to specify whether the related entities should be lazily loaded or eagerly loaded.
	Eager Fetch:
	--> An eager fetched attribute is fetched immediately along with the parent entity.
	Lazy Fetch:
	--> A Lazy fetched attribute is fetched only when it is accessed.

So, applying this to our Category class:
Class Category{
  int category_id; [Eager]
  String name; [Eager]
  User creator; [Eager]
  private List<Product> products; [Lazy]
}

By default, for collection attributes,the fetch type is lazy
and for non-collection attributes, the fetch type is eager.

*******************************************************************************
  This is how we mark the fetch manually for any attribute:
	@OneToMany(mappedBy = "category", fetch = FetchType.LAZY)
	private List<Product> products;
*******************************************************************************

Let's lok at the Cons and Pros of Such Lazy Loading:

PROS:
- This enables us to fetch only an object of the parent class without fetching the objects of the child class.
- We can fetch the child class object on demand when it is needed.
  --> Improves faster query execution time.
  --> Reduces memory consumption.

CONS:
	--> System may behave unexpectedly if we try to access the child class object when it is not loaded.
	--> We need to write additional code to handle the lazy loading of the child class objects.
*********************************************************************
Implementing the Lazy and Eager Fetching in our project:

Optional<Category> optionalCategory1 = categoryRepository.findById(UUID.fromString("1fa45539-11d9-4e1c-a04f-3d2d494d25f2"));
	if(!optionalCategory1.isEmpty()) {
				Category category1 = optionalCategory1.get();
				System.out.println("Category name is: " + category1.getName());
				System.out.println("Printing all products in the category");
				Thread.sleep(1000);
	}
	else {
			System.out.println("Category not found");
	}

			List<Product> products = productRepository.findAllByPrice_Currency("INR");
			System.out.println("Printing all products with currency INR");
  		for (Product product1: products) {
			System.out.println(product1.getTitle());
			System.out.print(" "+product1.getDescription());
  		System.out.print(" "+product1.getPrice().getCurrency());
   		System.out.print(" "+product1.getPrice().getPrice());
}

Now, there is no join with the product table for the category fetched for the passed category Id.

This happens because the Spring Data JPA fetches only the Categories and not the Products, so till the time the product is not fetched, the Product object instance is replaced by a proxy object- PersistentBag.

This is because the fetch type for the products attribute in the Category class is Lazy.
** Every repository call to the database in Spring Data JPA is a transaction,
** So, the transaction ends as soon as the findById method ends, and the proxy object is returned instead of the actual object.
This is similar to the fact that in SQL, every SQL query is a transaction of 1 statement.

** We can only LAZY Load an object of the child class when we are inside the transaction, the same transaction which fetched the parent object.
So if we use the @Transactional annotation on the method, then the method will be executed inside a transaction, and now we will have the products being returned for the category.
@Transactional
			public void run(String... args) throws Exception {
						// Demonstrate Lazy Loading
      			Optional<Category> optionalCategory1 = categoryRepository.findById
      					(UUID.fromString("1fa45539-11d9-4e1c-a04f-3d2d494d25f2"));
      			if(!optionalCategory1.isEmpty()) {
      				Category category1 = optionalCategory1.get();
      				System.out.println("Category name is: " + category1.getName());
      				System.out.println("Printing all products in the category");
      				Thread.sleep(1000);

      				//Trying to fetch the products from the category
      				List<Product> products = category1.getProducts();
      				Thread.sleep(1000);

      				for (Product product1: products) {
      					System.out.println(" Title: " + product1.getTitle());
      					System.out.println(" Description: "+product1.getDescription());
      					System.out.println(" Currency: "+product1.getPrice().getCurrency());
      					System.out.println(" Price: "+product1.getPrice().getPrice());
      				}
      			}
      			else {
      				System.out.println("Category not found");
      			}
      }

      Result:
      Category name is: Apple Devices
      Printing all products in the category
       Title: iPhone 15 Pro
       Description: The best iPhone Ever
       Currency: INR
       Price: 100000.0

So, we got the products only when we specifically requested for them in the transaction in the Application class using below:
	List<Product> products = category1.getProducts();

So basically what happens is that when we fetch the category, the products are not fetched, and only when we specifically request for the products, the products are fetched.
So, there are 2 database calls:
1. To fetch the category details from the category table.
2. To fetch the products for the category from the product table using the category_id column of the product table.
This is the gist of the Lazy Loading.

*****Creating the Category Controller ***************************************************
We will create a CategoryController class and create a method to fetch the category from the database based on a category id.

***** Category Controller: ******
@RestController
@RequestMapping("/categories")
public class CategoryController {

    @GetMapping("{id}")
    public Category getCategoryById(@PathVariable("id") String uuid) {
        return null;
    }
 }
 ***** Category Service: ******
public interface CategoryService {
     Category getCategoryById(String uuid);
}
 ***** Category ServiceImpl: ******
@Service
public class CategoryServiceImpl implements CategoryService{
    private CategoryRepository categoryRepository;

    public CategoryServiceImpl(CategoryRepository categoryRepository){
        this.categoryRepository = categoryRepository;
    }
    public Category getCategoryById(String uuid){
        categoryRepository.findById(UUID.fromString(uuid));
        return null;
    }
}

 ***** Category Repository: ******
    Optional<Category> findById(UUID uuid);

#### We have made the repository method return an Optional object as the findById method can return a null value.
This will help us to handle the null value in the controller. We no longer need to handle Null Pointer Exception in the controller. We can just check if the optional object is empty or not, and then directly get the products from the category in the controller.

We will update the service Impl to return the category object from the repository.
    public Category getCategoryById(String uuid){
        Optional<Category> optionalCategory = categoryRepository.findById(UUID.fromString(uuid));
       if(optionalCategory.isEmpty()){
           return null;
       }
       Category category = optionalCategory.get();
        List<Product> products = category.getProducts();
        return category;
    }
*************************************************************************************
implementing the Controller to return a category name:
@RestController
@RequestMapping("/categories")
public class CategoryController {
    private CategoryService categoryService;
    public CategoryController(CategoryService categoryService){
        this.categoryService = categoryService;
    }
    @GetMapping("{id}")
    public String getCategoryById(@PathVariable("id") String uuid) {
        Category category = categoryService.getCategoryById(uuid);
        System.out.println("Fetched Category Name is : "+ category.getName());
        return category.getName();
    }
}

*********************
Now let's try to return the product list for a category:
@RestController
@RequestMapping("/categories")
public class CategoryController {
    private CategoryService categoryService;
    public CategoryController(CategoryService categoryService){
        this.categoryService = categoryService;
    }
    @GetMapping("{id}")
    public Category getCategoryById(@PathVariable("id") String uuid) {
        Category category = categoryService.getCategoryById(uuid);
        System.out.println("Fetched Category Name is : "+ category.getName());
        return category.getName();
    }
}

--> We may encounter the infinite recursion problem here. This is because Category has a list of products and Product has a category object. So we have a cyclic dependency here, hence we have an infinite recursion problem.
--> To solve this, we can return Dtos instead of the actual entities.
@Getter@Setter
public class ProductDto {
    private String title;
    private String description;
    private String image;
    private Price price;
}

@RestController
@RequestMapping("/categories")
public class CategoryController {
    private CategoryService categoryService;
    public CategoryController(CategoryService categoryService){
        this.categoryService = categoryService;
    }
    @GetMapping("/{id}")
    public List<ProductDto> getCategory(@PathVariable("id") String uuid) {
        List<Product> products = categoryService.getCategoryById(uuid).getProducts();
        List<ProductDto> productDtos = new ArrayList<>();
        for (Product product: products) {
            ProductDto productDto = new ProductDto();
            productDto.setDescription(product.getDescription());
            productDto.setTitle(product.getTitle());
            productDto.setImage(product.getImage());
            productDto.setPrice(product.getPrice());
            productDtos.add(productDto);
        }
        return productDtos;
    }
}

Similarly, we can create a CategoryDto and return it from the controller. This category dto will have a list of product dtos. This will solve the infinite recursion problem.

@Getter @Setter
public class CategoryDto {
    private String name;
    private List<ProductDto> products;
}

And now the controller will look like this:
@RestController
@RequestMapping("/categories")
public class CategoryController {
    private CategoryService categoryService;
    public CategoryController(CategoryService categoryService){
        this.categoryService = categoryService;
    }
    @GetMapping("/{id}")
    public CategoryDto getCategory(@PathVariable("id") String uuid) {
        List<Product> products = categoryService.getCategoryById(uuid).getProducts();
        List<ProductDto> productDtos = new ArrayList<>();
        for (Product product: products) {
            ProductDto productDto = new ProductDto();
            productDto.setDescription(product.getDescription());
            productDto.setTitle(product.getTitle());
            productDto.setImage(product.getImage());
            productDto.setPrice(product.getPrice());
            productDtos.add(productDto);
        }
        CategoryDto categoryDto = new CategoryDto();
        categoryDto.setName(categoryService.getCategoryById(uuid).getName());
        categoryDto.setProducts(productDtos);
        return categoryDto;
    }
}
******************************************************************************************************
* We will now demonstrate the N+1 problem.
* The N+1 problem occurs when we have a collection of entities and we want to fetch the related entities for each entity in the collection.
* For example, we have a list of categories and we want to fetch the products for each category.
* In the context of a database relationship between categories and products, the N+1 problem refers to a scenario where, when we fetch a list of categories, and each category has a collection of associated products, we end up making N+1 queries to the database.

####   The problem: #########################################################

Let's see this in detail:
Here's a more detailed explanation:
--> N represents the number of categories you're retrieving.
--> 1 represents the initial query to get the list of categories.
--> +1 represents an additional query for each category to retrieve its associated products.
		For example, if we have 10 categories and each category has 5 products, without addressing the N+1 problem, we would end up making 11 queries:
				1 query to get the list of categories.
				10 additional queries (one for each category) to get their associated products.

* This can lead to a significant number of database queries, especially if we're dealing with large datasets. It can slow down our application and put unnecessary load on the database server.

####  Solution to the N+1 problem: #########################################################

To fix the N+1 problem is by using techniques like eager loading or batch fetching in the ORM configuration. This allows us to retrieve related entities in a more efficient manner.
In Spring Data JPA, for example, we can use @OneToMany or @ManyToMany annotations with fetch = FetchType.LAZY or configure batch fetching to control how related entities are loaded.

Implementation:
We have a Category entity with a one-to-many relationship to Product. The fetch = FetchType.LAZY attribute tells Hibernate to load the products of a category lazily, meaning they will only be fetched from the database when accessed.
--- Category Entity:---
   @OneToMany(mappedBy = "category", cascade = CascadeType.ALL, fetch = FetchType.LAZY)
       private List<Product> products;

Similarly, in the Product entity, the category is marked with fetch = FetchType.LAZY. This means that when we retrieve a product, the associated category will only be loaded when accessed.
--- Product Entity:---
	@ManyToOne(fetch = FetchType.LAZY)
		private Category category;

Using FetchType.LAZY:
	Now, let's assume we want to retrieve all categories and their associated products. With fetch = FetchType.LAZY, the products won't be loaded immediately:
	--- List<Category> categories = categoryRepository.findAll();
		At this point, categories is a list of categories, but the associated products haven't been loaded from the database yet.

	Accessing Products:
	When we access the products of a category, Hibernate will issue a separate query to the database to fetch the products:
   for (Category category : categories) {
       List<Product> products = category.getProducts(); // This triggers a query to get the products for this category
   }

This way, we avoid the N+1 problem. If we hadn't used fetch = FetchType.LAZY, Hibernate would have fetched all products eagerly, resulting in more queries.
##############################################################################################






