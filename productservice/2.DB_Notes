****class-9:11Sep Database-1 ********

Adding the database connection to the project
1. Add the Spring Data JPA dependency to the pom.xml
		<dependency>
			<groupId>org.springframework.boot</groupId>
			<artifactId>spring-boot-starter-data-jpa</artifactId>
		</dependency>

2. Add the MySql dependency to the pom.xml
        <dependency>
			<groupId>com.mysql</groupId>
			<artifactId>mysql-connector-j</artifactId>
			<scope>runtime</scope>
		</dependency>

3. Add the database connection properties to the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://${MYSQL_HOST:localhost}:3306/db_example
    spring.datasource.username=springuser
    spring.datasource.password=ThePassword
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

4. Add the database config in mysql workbench:
    create database scalerbackendproductservice;
    create user scalerbackendproductservice;
    grant all privileges on scalerbackendproductservice.* to scalerbackendproductservice;

5. Update the MYSQL host and user details in the application.properties
    # Spring DATASOURCE (DataSourceAutoConfiguration & DataSourceProperties)
    spring.jpa.hibernate.ddl-auto=update
    spring.datasource.url=jdbc:mysql://localhost:3306/scalerbackendproductservice
    spring.datasource.username=scalerbackendproductservice
    spring.datasource.driver-class-name=com.mysql.cj.jdbc.Driver
    #spring.jpa.show-sql: true

****** TODO: Mapped Superclass ******************************
1. Create a new class called BaseEntity
2. Add the @MappedSuperclass annotation to the BaseEntity class
3. Add the @Id and @GeneratedValue(strategy = GenerationType.IDENTITY) annotations to the id field

 ****UUID*****************************************
Let's look at the data type options for generating the primary key
*String:
  Having the Primary Keys as String is a terrible idea.
 -> Whenever we are storing a table in a particular database, for the primary key, an index is also created usually.
 --> The index is used to quickly search for a particular record in the table. (The index is stored in a data structure called a B-Tree.)
 --> However, the B-Tree data structure is not efficient when the data type is String. This indexing for String can be huge in itself and can significantly slow down the queries.
    --> The String data type is not efficient for the primary key and is almost always a terrible idea.

* Integer/Long:
    -> The Integer/Long data type is efficient for the primary key.

    *Benefits of the integer/long primary key:
        1. The primary key is auto generated by the database
        2. The primary key is unique across the table
        3. The primary key is sequential
        4. The Integer/Long data type is efficient for the primary key

    *Drawbacks of the integer/long primary key:
    --> However, the Integer/Long data type has a few drawbacks.
        --> When the systems are distributed, the Integer/Long data type is not efficient.
        --> When the systems are distributed, the Integer/Long data type is not unique neither sequential across the table.
        --> We would need a central server to generate the primary key for the table. But this can become a SPOF (Single Point of Failure) for the system.
        --> For auto-increment by 1 will definitely not work in a distributed system.
        --> We can only store the unique entries in a distributed manner as one query needs to wait for a running query to complete, get the unique id, increment that by 1 and then insert the next record. This is sequential and not efficient.

UUID:
    --> A better approach for the primary keys would be to
        -make it a concatenation of multiple variables, calculate those values and then use this.
        -This will be unique across the table and will be sequential as well.
     --> This is the idea behind UUID (Universally Unique Identifier).
--> UUID is a 128-bit number used to identify information in computer systems.
--> The UUID is generated using the current timestamp, the MAC address of the system, and a few other variables.
--> The UUID is unique across the table and is sequential as well.
--> The UUID is generated by the system and is not auto-incremented by 1.
UUID-7 is very popular nowadays to generate the primary key for the table. UUID-4 is the next popular one.

-> UUID as a String will be 36 characters long and will take up 36 bytes of space. (VARCHAR(36))
-> UUID as a byte array will be 16 bytes long and hence asr stored as a BINARY(16) in the database.
We are going to use UUID as the primary key for the product table

** Using UUID in the project
1. Add the UUID dependency to the pom.xml
    <dependency>
        <groupId>com.fasterxml.uuid</groupId>
        <artifactId>java-uuid-generator</artifactId>
        <version>4.0.1</version>
    </dependency>
2. Add the UUIDGenerator class to the project
3. Add the @GeneratedValue(generator = "UUID") and @GenericGenerator(name = "UUID", strategy = "org.hibernate.id.UUIDGenerator") annotations to the id field in the BaseEntity class.
4. Add the @Column(columnDefinition = "BINARY(16)", updatable = false, nullable = false) annotation to the id field in the BaseEntity class.








